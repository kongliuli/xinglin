# 报告单模板系统架构修复方案

## 一、硬编码数据绑定问题修复

**问题**：DataEntryViewModel的属性名与模板ElementId无自动关联

**修复方案**：

### 1. 创建FieldDefinition模型
```csharp
public class FieldDefinition
{
    public string ElementId { get; set; }     // 模板元素ID
    public string FieldKey { get; set; }      // 数据字段Key
    public FieldType Type { get; set; }       // 字段类型
    public bool IsRequired { get; set; }      // 是否必填
    public object DefaultValue { get; set; }  // 默认值
}
```

### 2. 实现FieldParserService
```csharp
public class FieldParserService
{
    public List<FieldDefinition> ParseFromTemplate(TemplateData template)
    {
        var definitions = new List<FieldDefinition>();
        foreach (var element in template.Layout.EditableElements)
        {
            definitions.Add(new FieldDefinition
            {
                ElementId = element.ElementId,
                FieldKey = element.ElementId, // 自动映射
                Type = MapToFieldType(element.Type),
                DefaultValue = element.Value
            });
        }
        return definitions;
    }
}
```

### 3. 重构DataEntryViewModel
- 移除硬编码属性
- 支持动态字段集合
- 实现字段值与模板元素的自动绑定

## 二、数据同步不完整问题修复

**问题**：模板编辑器的控件值更新后，数据录入面板无反向同步

**修复方案**：

### 1. 创建双向同步协调器
```csharp
public class BidirectionalSyncCoordinator
{
    private readonly ISharedDataService _sharedDataService;
    
    public BidirectionalSyncCoordinator(ISharedDataService sharedDataService)
    {
        _sharedDataService = sharedDataService;
        RegisterHandlers();
    }
    
    private void RegisterHandlers()
    {
        // DataEntry → TemplateEditor
        _sharedDataService.RegisterMessageHandler<FieldValuesChangedMessage>(message =>
        {
            SyncToTemplateEditor(message.FieldValues);
        });
        
        // TemplateEditor → DataEntry
        _sharedDataService.RegisterMessageHandler<ElementValueChangedMessage>(message =>
        {
            SyncToDataEntry(message.ElementId, message.NewValue);
        });
    }
}
```

### 2. 修改TemplateEditorViewModel
- 在SetDefaultValue方法中发送ElementValueChangedMessage
- 在SaveTemplateAsync方法中发送TemplateChanged消息

### 3. 实现消息类型
```csharp
public record FieldValuesChangedMessage(Dictionary<string, object> FieldValues);
public record ElementValueChangedMessage(string ElementId, object NewValue, object OldValue);
```

## 三、PDF预览触发机制不可靠问题修复

**问题**：依赖消息监听，缺少主动刷新机制

**修复方案**：

### 1. 改进PdfPreviewViewModel
- 添加自动刷新定时器
- 实现防抖机制
- 扩展消息监听场景

### 2. 实现防抖刷新逻辑
```csharp
public partial class PdfPreviewViewModel : ViewModelBase
{
    private Timer _autoRefreshTimer;
    private bool _isRefreshing = false;
    
    private void SchedulePdfRefresh(int delayMs)
    {
        if (_isRefreshing) return;
        _autoRefreshTimer.Change(delayMs, Timeout.Infinite);
    }
    
    private async void OnAutoRefresh(object state)
    {
        _isRefreshing = true;
        try
        {
            await RefreshPdfPreview();
        }
        finally
        {
            _isRefreshing = false;
        }
    }
}
```

### 3. 添加强制刷新命令
- 添加ForceRefreshPdfAsync命令
- 支持手动触发刷新

## 四、表格元素数据流断裂问题修复

**问题**：Table元素的Value类型复杂，未实现与录入面板的映射

**修复方案**：

### 1. 创建表格数据模型
```csharp
public class TableData : ObservableObject
{
    public string TableElementId { get; set; }
    public List<ColumnConfig> Columns { get; set; }
    public ObservableCollection<ObservableCollection<TableCellData>> Rows { get; set; }
    
    public TableData(ControlElement tableElement)
    {
        TableElementId = tableElement.ElementId;
        // 初始化表格结构
    }
}

public class TableCellData : ObservableObject
{
    public string ColumnId { get; set; }
    public string Value { get; set; }
    public CellControlType ControlType { get; set; }
}
```

### 2. 集成到DynamicDataEntryViewModel
- 添加表格数据集合
- 实现表格数据与模板元素的双向映射

### 3. 开发表格编辑界面
- 支持动态增删行
- 单元格类型多样性
- 表格配置持久化

## 五、实施顺序

1. **阶段一**：元数据驱动的动态字段生成
2. **阶段二**：双向同步机制
3. **阶段三**：PDF预览刷新改进
4. **阶段四**：表格元素数据流修复

## 六、技术保证

- 保持现有架构的稳定性
- 确保所有文件操作使用async/await
- 维持消息通信机制的健全性
- 保证撤销重做系统的完整性
- 支持模板版本控制的自动版本保存