# 常量整合与架构优化规划报告

> 文档版本：v1.0
> 创建日期：2026-01-31
> 适用项目：Demo_ReportPrinter

---

## 一、当前问题分析

### 1.1 已发现的关键问题

| 问题类型 | 具体问题 | 影响 | 优先级 |
|---------|---------|------|--------|
| **编译错误** | `PaperSizeType` 枚举未定义 | `LayoutMetadata.cs` 无法编译 | 🔴 高 |
| **编译错误** | `PaperSizeConstants` 类缺失 | `LayoutMetadata.cs` 调用失败 | 🔴 高 |
| **编译错误** | `PaperSizeInfo` 类缺失 | 纸张规格信息无法存储 | 🔴 高 |
| **功能缺失** | 拖拽功能未实现 | 画布无法交互操作 | 🔴 高 |
| **架构问题** | 常量分散在多个文件 | 维护困难，易产生不一致 | 🟡 中 |
| **验证缺失** | 纸张大小一致性验证缺失 | 画布与实际输出不一致 | 🟡 中 |

### 1.2 问题根本原因

1. **架构设计不完整**
   - 纸张规格系统未完整实现
   - 常量体系未统一规划

2. **依赖关系不清晰**
   - `LayoutMetadata` 依赖 `PaperSizeConstants`，但未同步实现
   - 缺少依赖注入和接口抽象

3. **功能实现滞后**
   - `TemplateEditorPanel.xaml.cs` 仅有15行，缺少核心交互逻辑
   - 拖拽、调整大小、吸附对齐等功能未实现

---

## 二、解决方案规划

### 2.1 短期解决方案（立即执行）

#### 目标：解决编译错误，使项目能够正常编译和运行

| 任务 | 文件 | 工作量 | 状态 |
|------|------|--------|------|
| 创建 `PaperSizeType` 枚举 | `PaperSizeConstants.cs` | 30分钟 | ✅ 已完成 |
| 创建 `PaperSizeInfo` 类 | `PaperSizeConstants.cs` | 30分钟 | ✅ 已完成 |
| 创建 `PaperSizeConstants` 类 | `PaperSizeConstants.cs` | 1小时 | ✅ 已完成 |
| 更新 `Constants.cs` | `Constants.cs` | 30分钟 | ✅ 已完成 |
| 测试编译 | 项目整体 | 15分钟 | ⏳ 待执行 |

#### 已完成的工作

1. ✅ **`PaperSizeConstants.cs`** - 纸张规格系统
   - 定义了 `PaperSizeType` 枚举（A4/A5/A3/Letter/Legal/Custom）
   - 实现了 `PaperSizeInfo` 类（存储纸张规格信息）
   - 实现了 `PaperSizeConstants` 静态类（提供工具方法）
   - 包含像素与毫米的转换方法（96 DPI）

2. ✅ **`Constants.cs`** - 统一常量体系
   - 整合了所有分类的常量
   - 新增了 `PaperSizes` 配置（纸张规格）
   - 新增了 `DragDrop` 配置（拖拽配置）
   - 新增了 `Display` 配置（显示配置）
   - 新增了 `Fonts` 配置（字体配置）
   - 新增了 `Table` 配置（表格配置）
   - 新增了 `Performance` 配置（性能配置）

### 2.2 中期解决方案（本周内）

#### 目标：实现画布拖拽和调整大小功能

| 任务 | 文件 | 工作量 | 优先级 |
|------|------|--------|--------|
| 实现拖拽行为 | `Behaviors/DragBehavior.cs` | 2小时 | 🔴 高 |
| 实现调整大小行为 | `Behaviors/ResizeBehavior.cs` | 2小时 | 🔴 高 |
| 实现吸附对齐 | `Behaviors/SnapBehavior.cs` | 1.5小时 | 🟡 中 |
| 实现 `TemplateEditorPanel.xaml.cs` | `TemplateEditorPanel.xaml.cs` | 3小时 | 🔴 高 |
| 更新 `TemplateEditorPanel.xaml` | `TemplateEditorPanel.xaml` | 2小时 | 🔴 高 |
| 实现坐标转换工具 | `Helpers/CoordinateHelper.cs` | 1小时 | 🟡 中 |

#### 详细实现计划

**1. 创建 Behaviors 目录结构**

```
Behaviors/
├── DragBehavior.cs          # 拖拽行为
├── ResizeBehavior.cs        # 调整大小行为
├── SnapBehavior.cs          # 吸附对齐行为
└── SelectionBehavior.cs     # 选择行为
```

**2. 实现 DragBehavior.cs**

核心功能：
- 监听鼠标事件（MouseDown、MouseMove、MouseUp）
- 计算偏移量并更新元素位置
- 应用网格吸附对齐
- 限制元素在画布边界内

**3. 实现 ResizeBehavior.cs**

核心功能：
- 检测8个调整大小的手柄（四角+四边）
- 计算新的宽度和高度
- 限制最小尺寸
- 应用网格吸附对齐

**4. 实现 SnapBehavior.cs**

核心功能：
- 计算网格对齐位置
- 计算与其他元素的对齐位置
- 自动吸附到对齐点
- 显示吸附辅助线

**5. 完善 TemplateEditorPanel.xaml.cs**

核心功能：
- 画布渲染逻辑
- 元素选择逻辑
- 拖拽事件处理
- 调整大小事件处理
- 坐标转换（逻辑坐标 ↔ 屏幕坐标）

**6. 更新 TemplateEditorPanel.xaml**

核心内容：
- 定义画布容器
- 定义元素模板
- 定义拖拽手柄模板
- 定义选择框样式

### 2.3 长期解决方案（下周）

#### 目标：实现高级功能和性能优化

| 任务 | 工作量 | 优先级 |
|------|--------|--------|
| 实现撤销/重做功能 | 4小时 | 🟡 中 |
| 实现多选功能 | 3小时 | 🟡 中 |
| 实现元素对齐工具 | 2小时 | 🟢 低 |
| 实现元素分组/解组 | 3小时 | 🟢 低 |
| 实现复制/粘贴功能 | 2小时 | 🟢 低 |
| 性能优化（虚拟化） | 6小时 | 🟡 中 |
| 纸张大小一致性验证 | 4小时 | 🟡 中 |

---

## 三、详细实现方案

### 3.1 纸张规格系统架构

#### 3.1.1 类图

```
┌─────────────────┐
│ PaperSizeType   │ (枚举)
├─────────────────┤
│ Custom          │
│ A4              │
│ A5              │
│ A3              │
│ Letter          │
│ Legal           │
└────────┬────────┘
         │
         │ 使用
         ↓
┌─────────────────────────┐
│  PaperSizeInfo          │
├─────────────────────────┤
│ Type: PaperSizeType     │
│ Name: string            │
│ Width: double (mm)      │
│ Height: double (mm)     │
├─────────────────────────┤
│ + PortraitPixelWidth    │
│ + PortraitPixelHeight   │
│ + LandscapePixelWidth   │
│ + LandscapePixelHeight  │
└─────────────────────────┘
         │
         │ 包含在
         ↓
┌─────────────────────────────┐
│  PaperSizeConstants (静态类) │
├─────────────────────────────┤
│ + AllPaperSizes: List<>     │
│ + Default: PaperSizeInfo    │
├─────────────────────────────┤
│ + GetByType()               │
│ + GetByName()               │
│ + MmToPixelConvert()        │
│ + PixelToMmConvert()        │
│ + GetDisplayWidth()         │
│ + GetDisplayHeight()        │
└─────────────────────────────┘
         │
         │ 引用
         ↓
┌─────────────────────────┐
│  LayoutMetadata          │
├─────────────────────────┤
│ PaperType: PaperSizeType │
│ PaperWidth: double       │
│ PaperHeight: double      │
│ IsLandscape: bool        │
├─────────────────────────┤
│ + SetPaperSize()         │
│ + SetCustomPaperSize()   │
│ + ActualWidth            │
│ + ActualHeight           │
└─────────────────────────┘
```

#### 3.1.2 坐标转换流程

```
逻辑坐标（mm）
    ↓
LayoutMetadata.PaperWidth/Height
    ↓
PaperSizeConstants.MmToPixelConvert()
    ↓
屏幕坐标（pixel）
    ↓
Canvas.ActualWidth/ActualHeight
    ↓
显示坐标（考虑缩放）
```

#### 3.1.3 纸张尺寸对照表

| 纸张类型 | 宽度 | 高度 | 横向像素 | 横向像素 | 纵向像素 | 纵向像素 |
|---------|------|------|----------|----------|----------|----------|
| A4 | 210mm | 297mm | 1122px | 793px | 793px | 1122px |
| A5 | 148mm | 210mm | 793px | 559px | 559px | 793px |
| A3 | 297mm | 420mm | 1587px | 1122px | 1122px | 1587px |
| Letter | 216mm | 279mm | 1156px | 816px | 816px | 1156px |
| Legal | 216mm | 356mm | 1156px | 1345px | 1345px | 1156px |

**注：像素值基于96 DPI计算，计算公式：像素 = 毫米 × 3.7795**

---

### 3.2 拖拽系统架构

#### 3.2.1 类图

```
┌─────────────────────────┐
│  DragBehavior            │
├─────────────────────────┤
│ - isDragging: bool       │
│ - dragStartPoint: Point  │
│ - originalPosition: Point│
│ - element: ControlElement│
├─────────────────────────┤
│ + OnAttached()           │
│ + OnDetached()           │
│ - OnMouseDown()          │
│ - OnMouseMove()          │
│ - OnMouseUp()            │
│ - UpdatePosition()       │
│ - ApplySnapToGrid()      │
│ - ConstraintToBounds()   │
└─────────────────────────┘

┌─────────────────────────┐
│  ResizeBehavior          │
├─────────────────────────┤
│ - isResizing: bool       │
│ - resizeHandle: Handle   │
│ - originalSize: Size     │
│ - originalPosition: Point│
│ - element: ControlElement│
├─────────────────────────┤
│ + OnAttached()           │
│ + OnDetached()           │
│ - OnHandleMouseDown()    │
│ - OnMouseMove()          │
│ - OnMouseUp()            │
│ - UpdateSize()           │
│ - ApplySnapToGrid()      │
│ - ConstraintToMinSize()  │
└─────────────────────────┘

┌─────────────────────────┐
│  SnapBehavior            │
├─────────────────────────┤
│ - snapDistance: double   │
│ - gridSize: double       │
├─────────────────────────┤
│ + SnapToGrid()           │
│ + FindSnapPoints()       │
│ + DrawSnapLines()        │
└─────────────────────────┘
```

#### 3.2.2 拖拽流程

```
用户鼠标按下
    ↓
DragBehavior.OnMouseDown()
    ↓
记录初始位置 (dragStartPoint, originalPosition)
设置 isDragging = true
    ↓
用户鼠标移动
    ↓
DragBehavior.OnMouseMove()
    ↓
如果 isDragging
    ↓
计算新位置 = 鼠标位置 - dragStartPoint + originalPosition
    ↓
应用网格对齐 (SnapBehavior.SnapToGrid())
    ↓
限制在边界内 (ConstraintToBounds())
    ↓
更新元素位置 (element.X, element.Y)
    ↓
触发布局更新
    ↓
用户鼠标释放
    ↓
DragBehavior.OnMouseUp()
    ↓
设置 isDragging = false
    ↓
记录撤销/重做操作
```

#### 3.2.3 调整大小流程

```
用户鼠标按下（在调整手柄上）
    ↓
ResizeBehavior.OnHandleMouseDown()
    ↓
记录初始尺寸和位置 (originalSize, originalPosition)
记录拖拽手柄类型 (resizeHandle)
设置 isResizing = true
    ↓
用户鼠标移动
    ↓
ResizeBehavior.OnMouseMove()
    ↓
如果 isResizing
    ↓
根据手柄类型计算新尺寸
    ├─ 左上角：修改 X, Y, Width, Height
    ├─ 右上角：修改 Y, Width, Height
    ├─ 左下角：修改 X, Width, Height
    ├─ 右下角：修改 Width, Height
    ├─ 上边：修改 Y, Height
    ├─ 下边：修改 Height
    ├─ 左边：修改 X, Width
    └─ 右边：修改 Width
    ↓
应用网格对齐 (SnapBehavior.SnapToGrid())
    ↓
限制最小尺寸 (ConstraintToMinSize())
    ↓
更新元素尺寸 (element.X, element.Y, element.Width, element.Height)
    ↓
触发布局更新
    ↓
用户鼠标释放
    ↓
ResizeBehavior.OnMouseUp()
    ↓
设置 isResizing = false
    ↓
记录撤销/重做操作
```

---

### 3.3 坐标转换系统

#### 3.3.1 坐标系统定义

```
┌─────────────────────────────────────────┐
│  逻辑坐标系统（Logical Coordinate System）  │
│  单位：毫米                              │
│  原点：左上角 (0, 0)                      │
│  用于：模板定义、数据存储                  │
└─────────────────────────────────────────┘
            ↓ 转换
┌─────────────────────────────────────────┐
│  屏幕坐标系统（Screen Coordinate System）  │
│  单位：像素                              │
│  原点：左上角 (0, 0)                      │
│  用于：画布渲染、UI交互                    │
└─────────────────────────────────────────┘
            ↓ 转换
┌─────────────────────────────────────────┐
│  显示坐标系统（Display Coordinate System） │
│  单位：像素                              │
│  原点：画布左上角                         │
│  用于：最终渲染、输出                      │
└─────────────────────────────────────────┘
```

#### 3.3.2 转换方法

```csharp
public static class CoordinateHelper
{
    /// <summary>
    /// 逻辑坐标 → 屏幕坐标（不考虑缩放）
    /// </summary>
    public static Point LogicalToScreen(Point logicalPoint, double dpi = 96)
    {
        double mmToPixel = dpi / 25.4; // 1 inch = 25.4 mm
        return new Point(
            logicalPoint.X * mmToPixel,
            logicalPoint.Y * mmToPixel
        );
    }

    /// <summary>
    /// 屏幕坐标 → 逻辑坐标（不考虑缩放）
    /// </summary>
    public static Point ScreenToLogical(Point screenPoint, double dpi = 96)
    {
        double pixelToMm = 25.4 / dpi;
        return new Point(
            screenPoint.X * pixelToMm,
            screenPoint.Y * pixelToMm
        );
    }

    /// <summary>
    /// 应用缩放（逻辑坐标 → 显示坐标）
    /// </summary>
    public static Point ApplyScale(Point point, double scale)
    {
        return new Point(
            point.X * scale,
            point.Y * scale
        );
    }

    /// <summary>
    /// 移除缩放（显示坐标 → 逻辑坐标）
    /// </summary>
    public static Point RemoveScale(Point point, double scale)
    {
        return new Point(
            point.X / scale,
            point.Y / scale
        );
    }
}
```

---

## 四、验证方案

### 4.1 编译验证

**验证步骤：**

1. 清理项目
```bash
dotnet clean
```

2. 重新构建项目
```bash
dotnet build
```

3. 检查编译错误
```bash
# 预期结果：编译成功，无错误
```

### 4.2 纸张大小一致性验证

**验证项目：**

| 验证项 | 预期值 | 验证方法 |
|--------|--------|---------|
| A4纵向宽度 | 793px | 检查 Canvas.ActualWidth |
| A4纵向高度 | 1122px | 检查 Canvas.ActualHeight |
| A5横向宽度 | 793px | 检查 Canvas.ActualWidth |
| A5横向高度 | 559px | 检查 Canvas.ActualHeight |
| 坐标转换精度 | ±0.5px | 对比计算值与实际值 |

**验证代码示例：**

```csharp
[Test]
public void Test_PaperSizeConsistency_A4Portrait()
{
    var layout = new LayoutMetadata();
    layout.SetPaperSize(PaperSizeType.A4);
    layout.IsLandscape = false;

    // 逻辑坐标
    double logicalWidth = layout.ActualWidth;  // 210mm
    double logicalHeight = layout.ActualHeight; // 297mm

    // 屏幕坐标
    double screenPixelWidth = logicalWidth * 3.7795;  // 793.7px
    double screenPixelHeight = logicalHeight * 3.7795; // 1122.5px

    // 验证
    Assert.AreEqual(210, logicalWidth);
    Assert.AreEqual(297, logicalHeight);
    Assert.AreEqual(793.7, screenPixelWidth, 0.1);
    Assert.AreEqual(1122.5, screenPixelHeight, 0.1);
}

[Test]
public void Test_PaperSizeConsistency_A5Landscape()
{
    var layout = new LayoutMetadata();
    layout.SetPaperSize(PaperSizeType.A5);
    layout.IsLandscape = true;

    // 逻辑坐标
    double logicalWidth = layout.ActualWidth;  // 210mm
    double logicalHeight = layout.ActualHeight; // 148mm

    // 屏幕坐标
    double screenPixelWidth = logicalWidth * 3.7795;  // 793.7px
    double screenPixelHeight = logicalHeight * 3.7795; // 559.2px

    // 验证
    Assert.AreEqual(210, logicalWidth);
    Assert.AreEqual(148, logicalHeight);
    Assert.AreEqual(793.7, screenPixelWidth, 0.1);
    Assert.AreEqual(559.2, screenPixelHeight, 0.1);
}
```

### 4.3 拖拽功能验证

**验证项目：**

| 验证项 | 预期行为 | 验证方法 |
|--------|---------|---------|
| 拖拽开始 | 元素跟随鼠标移动 | 模拟鼠标按下并移动 |
| 拖拽移动 | 位置实时更新 | 检查 X, Y 值变化 |
| 网格吸附 | 自动对齐到网格点 | 检查位置是网格的倍数 |
| 边界限制 | 不超出画布范围 | 检查位置是否在有效范围内 |
| 拖拽结束 | 停止跟随鼠标 | 模拟鼠标释放 |

**验证代码示例：**

```csharp
[Test]
public async Task Test_DragBehavior_DragElement()
{
    var element = new ControlElement
    {
        Type = ControlType.TextBox,
        X = 100,
        Y = 100,
        Width = 100,
        Height = 30
    };

    var canvas = new Canvas();
    canvas.Children.Add(new Border
    {
        Width = element.Width,
        Height = element.Height,
        Tag = element
    });

    var behavior = new DragBehavior();
    Interaction.GetBehaviors(canvas).Add(behavior);

    // 模拟鼠标按下
    var mouseDownArgs = new MouseButtonEventArgs(
        Mouse.PrimaryDevice,
        0,
        MouseButton.Left)
    {
        RoutedEvent = UIElement.MouseLeftButtonDownEvent,
        Source = canvas
    };
    canvas.RaiseEvent(mouseDownArgs);

    // 模拟鼠标移动
    var mouseMoveArgs = new MouseEventArgs(
        Mouse.PrimaryDevice,
        0)
    {
        RoutedEvent = UIElement.MouseMoveEvent,
        GetPosition = _ => new Point(150, 150)
    };
    canvas.RaiseEvent(mouseMoveArgs);

    // 验证元素位置更新
    await Task.Delay(100);
    Assert.AreEqual(150, element.X);
    Assert.AreEqual(150, element.Y);
}
```

---

## 五、实施计划

### 5.1 时间线

```
第1天（今天）
├─ ✅ 创建 PaperSizeConstants.cs
├─ ✅ 更新 Constants.cs
├─ ⏳ 测试编译
└─ ⏳ 修复编译错误

第2-3天（本周）
├─ ⏳ 创建 Behaviors 目录
├─ ⏳ 实现 DragBehavior.cs
├─ ⏳ 实现 ResizeBehavior.cs
├─ ⏳ 实现 SnapBehavior.cs
├─ ⏳ 完善 TemplateEditorPanel.xaml.cs
├─ ⏳ 更新 TemplateEditorPanel.xaml
└─ ⏳ 单元测试

第4-5天（下周）
├─ ⏳ 实现撤销/重做功能
├─ ⏳ 实现多选功能
├─ ⏳ 实现对齐工具
├─ ⏳ 性能优化
└─ ⏳ 纸张大小一致性验证
```

### 5.2 里程碑

| 里程碑 | 日期 | 交付物 |
|--------|------|--------|
| **M1: 编译成功** | 今天 | 项目可正常编译 |
| **M2: 拖拽功能** | 第3天 | 元素可拖拽移动 |
| **M3: 调整大小** | 第3天 | 元素可调整大小 |
| **M4: 基础交互** | 第3天 | 完整的画布交互 |
| **M5: 高级功能** | 第5天 | 撤销/重做、多选等 |
| **M6: 性能优化** | 第5天 | 流畅的交互体验 |

---

## 六、风险与应对

### 6.1 技术风险

| 风险 | 影响 | 概率 | 应对措施 |
|------|------|------|---------|
| 拖拽性能问题 | 用户体验差 | 中 | 使用虚拟化、延迟渲染 |
| 坐标转换精度问题 | 位置不准确 | 低 | 使用高精度浮点数 |
| 网格吸附计算复杂 | 响应延迟 | 中 | 优化算法，缓存计算结果 |
| 边界约束计算错误 | 元素超出边界 | 低 | 严格测试边界条件 |

### 6.2 项目风险

| 风险 | 影响 | 概率 | 应对措施 |
|------|------|------|---------|
| 工期延误 | 影响整体进度 | 中 | 分阶段交付，优先核心功能 |
| 需求变更 | 重复开发 | 低 | 锁定需求范围，变更走流程 |
| 人员变动 | 知识断层 | 低 | 完善文档，代码注释 |

---

## 七、总结

### 7.1 已完成工作

1. ✅ **`PaperSizeConstants.cs`** - 完整的纸张规格系统
2. ✅ **`Constants.cs`** - 统一的常量体系
3. ✅ **架构规划** - 清晰的技术路线图
4. ✅ **验证方案** - 完善的测试计划

### 7.2 下一步工作

1. ⏳ **测试编译** - 确保项目可以正常编译
2. ⏳ **实现拖拽** - 创建 Behaviors 并实现拖拽功能
3. ⏳ **实现调整大小** - 实现元素调整大小功能
4. ⏳ **完善画布** - 更新 TemplateEditorPanel.xaml 和 .cs

### 7.3 关键决策

1. **架构决策**
   - 采用行为模式（Behavior）实现拖拽和调整大小
   - 使用静态类统一管理常量
   - 分离逻辑坐标和屏幕坐标

2. **技术选型**
   - 使用 WPF 的 `System.Windows.Interactivity` 库
   - 使用 MVVM 模式，分离 UI 和逻辑
   - 使用单元测试保证质量

---

**文档结束**
