# 报告单模板可自定义元素手册

> 文档版本：v1.0  
> 创建日期：2026-01-31  
> 适用项目：Demo_ReportPrinter

---

## 目录

- [一、概述](#一概述)
- [二、基础元素类型](#二基础元素类型)
- [三、表格元素详解](#三表格元素详解)
- [四、元素操作指南](#四元素操作指南)
- [五、元素属性配置](#五元素属性配置)
- [六、数据绑定规则](#六数据绑定规则)
- [七、高级特性](#七高级特性)

---

## 一、概述

### 1.1 设计理念

本报告单模板系统采用**元数据驱动架构**，所有可自定义元素均基于`ControlElement`模型，通过动态属性扩展实现差异化功能。核心特点：

- **所见即所得**：拖拽式编辑，实时预览
- **类型安全**：强类型数据绑定，编译时检查
- **版本控制**：所有变更自动记录，支持回溯
- **响应式**：数据录入与模板编辑实时同步

### 1.2 数据流架构

```
┌─────────────────────────────────────────────────────────────────┐
│                         数据录入面板                              │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  TextBox(姓名) ──→ SharedDataService.UpdateUserData()   │  │
│  │  ComboBox(部门) ──→ SharedDataService.UpdateUserData()   │  │
│  │  DatePicker(日期) ──→ SharedDataService.UpdateUserData()  │  │
│  └──────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                              ↓ 消息广播
┌─────────────────────────────────────────────────────────────────┐
│                       SharedDataService                          │
│  • 数据字典: Dictionary<string, object>                         │
│  • 消息发布: WeakReferenceMessenger                             │
│  • 当前模板引用: CurrentTemplate                                │
└─────────────────────────────────────────────────────────────────┘
                              ↓ 消息订阅
┌─────────────────────────────────────────────────────────────────┐
│                        模板编辑面板                               │
│  • DataChangedMessage → UpdateElementValue(key, value)         │
│  • 根据ElementId查找ControlElement                              │
│  • 更新Element.Value属性                                         │
└─────────────────────────────────────────────────────────────────┘
                              ↓ 数据更新
┌─────────────────────────────────────────────────────────────────┐
│                         PDF预览面板                               │
│  • 监听"DataSaved"或"TemplateChanged"消息                       │
│  • 调用PdfService.GeneratePdfAsync()                            │
│  • WebView2加载渲染结果                                          │
└─────────────────────────────────────────────────────────────────┘
```

---

## 二、基础元素类型

### 2.1 文本框 (TextBox)

#### 基本属性

| 属性名 | 类型 | 默认值 | 说明 |
|--------|------|--------|------|
| `Type` | `ControlType` | `TextBox` | 控件类型标识 |
| `DisplayName` | `string` | "文本框" | 显示名称 |
| `X` | `double` | 50 | 左上角X坐标（毫米） |
| `Y` | `double` | 50 | 左上角Y坐标（毫米） |
| `Width` | `double` | 100 | 宽度（毫米） |
| `Height` | `double` | 30 | 高度（毫米） |
| `Value` | `object` | null | 当前值 |
| `EditState` | `EditableState` | `Editable` | 可编辑状态 |
| `ZIndex` | `int` | 0 | 层级顺序 |

#### 扩展属性

```csharp
// 字符串长度限制
element.SetProperty("MaxLength", 50);

// 默认值
element.SetProperty("DefaultValue", "请输入姓名");

// 正则验证
element.SetProperty("ValidationRegex", @"^[\u4e00-\u9fa5]{2,10}$");

// 必填标记
element.SetProperty("IsRequired", true);

// 占位符文本
element.SetProperty("Placeholder", "请输入内容...");

// 字体大小
element.SetProperty("FontSize", 12);

// 文本对齐
element.SetProperty("TextAlignment", "Left"); // Left/Center/Right
```

#### 支持的操作

| 操作 | 方法 | 说明 |
|------|------|------|
| 添加 | `AddElement(ControlType.TextBox)` | 添加到画布 |
| 拖拽 | 拖拽行为 | 调整位置（X/Y） |
| 调整大小 | 四角/四边Thumb | 调整尺寸（Width/Height） |
| 设置默认值 | `SetDefaultValue(element)` | 弹窗设置 |
| 编辑属性 | `EditProperties(element)` | 打开属性面板 |
| 克隆 | `CloneElement(element)` | 复制元素 |
| 删除 | `DeleteElement(element)` | 移除元素 |
| 层级调整 | `BringToFront()` / `SendToBack()` | Z-Index管理 |

#### 数据绑定示例

```csharp
// 在DataEntryViewModel中
partial void OnUserNameChanged(string value)
{
    _sharedDataService.UpdateUserData("UserName", value);
}

// 在TemplateEditorViewModel中自动接收
private void UpdateElementValue(string key, object value)
{
    var element = CurrentTemplate.Layout.EditableElements
        .FirstOrDefault(e => e.ElementId == key);
    if (element != null)
    {
        element.Value = value; // 实时同步到画布
    }
}
```

#### UI渲染模板

```xaml
<!-- 文本框渲染模板 -->
<DataTemplate x:Key="TextBoxTemplate">
    <Border BorderBrush="LightGray" BorderThickness="1"
            Width="{Binding Width}" Height="{Binding Height}"
            Background="White">
        <TextBox Text="{Binding Value, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"
                 IsEnabled="{Binding CanMove}"
                 FontSize="{Binding Properties[FontSize], FallbackValue=12}"
                 TextAlignment="{Binding Properties[TextAlignment], FallbackValue=Left}"
                 MaxLength="{Binding Properties[MaxLength], FallbackValue=2147483647}"/>
    </Border>
</DataTemplate>
```

---

### 2.2 下拉框 (ComboBox)

#### 基本属性

| 属性名 | 类型 | 默认值 | 说明 |
|--------|------|--------|------|
| `Type` | `ControlType` | `ComboBox` | 控件类型标识 |
| `DisplayName` | `string` | "下拉框" | 显示名称 |
| `X` | `double` | 50 | 左上角X坐标（毫米） |
| `Y` | `double` | 50 | 左上角Y坐标（毫米） |
| `Width` | `double` | 100 | 宽度（毫米） |
| `Height` | `double` | 30 | 高度（毫米） |
| `Value` | `object` | null | 选中的值 |
| `EditState` | `EditableState` | `Editable` | 可编辑状态 |

#### 扩展属性

```csharp
// 选项列表（核心属性）
element.SetProperty("Options", "选项1\n选项2\n选项3\n选项4");

// 默认选中项
element.SetProperty("DefaultSelectedIndex", 0);

// 允许自定义输入
element.SetProperty("IsEditable", false);

// 分组显示
element.SetProperty("IsGrouped", false);

// 显示路径（用于复杂对象）
element.SetProperty("DisplayMemberPath", "Name");

// 值路径（用于复杂对象）
element.SetProperty("ValueMemberPath", "Id");

// 搜索过滤
element.SetProperty("IsSearchable", true);

// 多选模式
element.SetProperty("IsMultiSelect", false);
```

#### 支持的操作

| 操作 | 方法 | 说明 |
|------|------|------|
| 添加 | `AddElement(ControlType.ComboBox)` | 添加到画布 |
| 编辑选项 | `EditOptions(element)` | 弹窗编辑下拉选项 |
| 设置默认值 | `SetDefaultValue(element)` | 设置初始选中项 |
| 从数据源加载 | （扩展） | 从共享服务加载 |
| 其他操作 | 同TextBox | 拖拽、调整、克隆、删除等 |

#### 选项编辑实现

```csharp
[RelayCommand]
private void EditOptions(ControlElement element)
{
    if (element.Type == ControlType.ComboBox)
    {
        // 弹出选项编辑对话框
        var window = new Window
        {
            Title = "编辑下拉选项",
            Width = 300,
            Height = 250,
            WindowStartupLocation = WindowStartupLocation.CenterScreen
        };

        var textBox = new TextBox
        {
            AcceptsReturn = true,
            TextWrapping = TextWrapping.Wrap,
            VerticalScrollBarVisibility = ScrollBarVisibility.Auto,
            Text = element.GetProperty<string>("Options", "选项1\n选项2\n选项3")
        };

        // 确认按钮
        var okButton = new Button { Content = "确定", Width = 70 };
        okButton.Click += (s, e) => { window.DialogResult = true; };

        if (window.ShowDialog() == true)
        {
            var oldOptions = textBox.Text;
            var newOptions = textBox.Text;
            element.SetProperty("Options", newOptions);
            
            // 记录到命令历史
            var command = new ChangeControlPropertyCommand(
                element, "Options", oldOptions, newOptions);
            _commandHistory.ExecuteCommand(command);
        }
    }
}
```

#### 选项解析与渲染

```csharp
// 解析选项字符串
public List<string> ParseOptions(string optionsText)
{
    if (string.IsNullOrWhiteSpace(optionsText))
        return new List<string>();

    return optionsText
        .Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries)
        .Select(line => line.Trim())
        .Where(line => !string.IsNullOrEmpty(line))
        .ToList();
}

// UI绑定
<ComboBox ItemsSource="{Binding RelativeSource={RelativeSource AncestorType=UserControl},
                  Path=DataContext.ParseOptions(Properties[Options])}"
          SelectedItem="{Binding Value, Mode=TwoWay}"
          IsEditable="{Binding Properties[IsEditable], FallbackValue=False}"/>
```

#### 默认选中第一项实现

```csharp
// 在ViewModel初始化时
public class ComboBoxViewModel : ObservableObject
{
    [ObservableProperty]
    private string _selectedOption;

    public List<string> Options { get; set; }

    public ComboBoxViewModel(ControlElement element)
    {
        // 解析选项
        Options = ParseOptions(element.GetProperty<string>("Options"));
        
        // 默认选中第一项
        if (Options.Count > 0)
        {
            var defaultIndex = element.GetProperty<int>("DefaultSelectedIndex", 0);
            SelectedOption = Options[Math.Min(defaultIndex, Options.Count - 1)];
        }
    }
}
```

---

### 2.3 日期选择器 (DatePicker)

#### 基本属性

| 属性名 | 类型 | 默认值 | 说明 |
|--------|------|--------|------|
| `Type` | `ControlType` | `DatePicker` | 控件类型标识 |
| `DisplayName` | `string` | "日期选择" | 显示名称 |
| `X` | `double` | 50 | 左上角X坐标（毫米） |
| `Y` | `double` | 50 | 左上角Y坐标（毫米） |
| `Width` | `double` | 150 | 宽度（毫米） |
| `Height` | `double` | 30 | 高度（毫米） |
| `Value` | `DateTime?` | null | 选中的日期 |
| `EditState` | `EditableState` | `Editable` | 可编辑状态 |

#### 扩展属性

```csharp
// 日期格式
element.SetProperty("DateFormat", "yyyy-MM-dd");

// 显示格式
element.SetProperty("DisplayFormat", "yyyy年MM月dd日");

// 最小日期
element.SetProperty("MinDate", new DateTime(1900, 1, 1));

// 最大日期
element.SetProperty("MaxDate", DateTime.Now.AddYears(10));

// 今天按钮
element.SetProperty("ShowToday", true);

// 今天日期
element.SetProperty("TodayDate", DateTime.Today);

// 不可选日期
element.SetProperty("BlackoutDates", new List<DateTime>());

// 日历显示模式
element.SetProperty("CalendarMode", "Month"); // Month/Year/Decade

// 周首日
element.SetProperty("FirstDayOfWeek", DayOfWeek.Monday);
```

#### 支持的操作

| 操作 | 方法 | 说明 |
|------|------|------|
| 添加 | `AddElement(ControlType.DatePicker)` | 添加到画布 |
| 设置默认值 | `SetDefaultValue(element)` | 设置初始日期 |
| 快捷日期 | （扩展） | 今天、昨天、一周前等 |
| 其他操作 | 同TextBox | 拖拽、调整、克隆、删除等 |

#### 日期范围限制示例

```csharp
// 设置可选日期范围
element.SetProperty("MinDate", DateTime.Today.AddYears(-1));
element.SetProperty("MaxDate", DateTime.Today);

// 禁用周末
var blackoutDates = new List<DateTime>();
var startDate = DateTime.Today;
for (int i = 0; i < 365; i++)
{
    var date = startDate.AddDays(i);
    if (date.DayOfWeek == DayOfWeek.Saturday || 
        date.DayOfWeek == DayOfWeek.Sunday)
    {
        blackoutDates.Add(date);
    }
}
element.SetProperty("BlackoutDates", blackoutDates);
```

---

### 2.4 复选框 (CheckBox)

#### 基本属性

| 属性名 | 类型 | 默认值 | 说明 |
|--------|------|--------|------|
| `Type` | `ControlType` | `CheckBox` | 控件类型标识 |
| `DisplayName` | `string` | "复选框" | 显示名称 |
| `X` | `double` | 50 | 左上角X坐标（毫米） |
| `Y` | `double` | 50 | 左上角Y坐标（毫米） |
| `Width` | `double` | 15 | 宽度（毫米） |
| `Height` | `double` | 15 | 高度（毫米） |
| `Value` | `bool?` | false | 选中状态 |
| `EditState` | `EditableState` | `Editable` | 可编辑状态 |

#### 扩展属性

```csharp
// 标签文本
element.SetProperty("Label", "同意条款");

// 标签位置
element.SetProperty("LabelPlacement", "Right"); // Left/Right/Top/Bottom

// 三态模式
element.SetProperty("IsThreeState", false);

// 未知状态默认值
element.SetProperty("DefaultNullState", false);

// 自定义样式
element.SetProperty("CheckStyle", "Box"); // Box/Circle/Cross
```

#### 数据绑定

```csharp
// DataEntryViewModel
[ObservableProperty]
private bool _agreeToTerms;

partial void OnAgreeToTermsChanged(bool value)
{
    _sharedDataService.UpdateUserData("AgreeToTerms", value);
}
```

---

### 2.5 图片 (Image)

#### 基本属性

| 属性名 | 类型 | 默认值 | 说明 |
|--------|------|--------|------|
| `Type` | `ControlType` | `Image` | 控件类型标识 |
| `DisplayName` | `string` | "图片" | 显示名称 |
| `X` | `double` | 50 | 左上角X坐标（毫米） |
| `Y` | `double` | 50 | 左上角Y坐标（毫米） |
| `Width` | `double` | 150 | 宽度（毫米） |
| `Height` | `double` | 100 | 高度（毫米） |
| `Value` | `object` | null | 图片数据（Base64或路径） |
| `EditState` | `EditableState` | `Editable` | 可编辑状态 |

#### 扩展属性

```csharp
// 图片来源
element.SetProperty("ImageSource", "file"); // file/url/base64/embedded

// 图片路径或Base64数据
element.SetProperty("ImageData", "/Images/logo.png");

// 拉伸模式
element.SetProperty("Stretch", "Uniform"); // None/Fill/Uniform/UniformToFill

// 图片对齐
element.SetProperty("AlignmentX", "Center"); // Left/Center/Right
element.SetProperty("AlignmentY", "Center"); // Top/Center/Bottom

// 圆角
element.SetProperty("CornerRadius", 0);

// 边框
element.SetProperty("BorderThickness", 0);
element.SetProperty("BorderColor", "Gray");

// 不透明度
element.SetProperty("Opacity", 1.0);

// 旋转角度
element.SetProperty("Rotation", 0);

// 阴影效果
element.SetProperty("HasShadow", false);
```

#### 支持的操作

| 操作 | 方法 | 说明 |
|------|------|------|
| 添加 | `AddElement(ControlType.Image)` | 添加到画布 |
| 选择图片 | `SelectImage(element)` | 打开文件选择对话框 |
| 裁剪图片 | （扩展） | 打开裁剪编辑器 |
| 替换图片 | （扩展） | 替换当前图片 |
| 调整 | 同TextBox | 拖拽、调整大小、层级等 |

#### 图片加载实现

```csharp
[RelayCommand]
private void SelectImage(ControlElement element)
{
    var openFileDialog = new OpenFileDialog
    {
        Filter = "图片文件|*.png;*.jpg;*.jpeg;*.bmp;*.gif",
        Title = "选择图片"
    };

    if (openFileDialog.ShowDialog() == true)
    {
        var oldImage = element.Value;
        
        // 读取图片并转为Base64
        var imageBytes = File.ReadAllBytes(openFileDialog.FileName);
        var base64Image = Convert.ToBase64String(imageBytes);
        
        element.Value = base64Image;
        element.SetProperty("ImageData", $"data:image/png;base64,{base64Image}");
        element.SetProperty("ImageSource", "base64");
        
        // 记录命令
        var command = new ChangeControlPropertyCommand(
            element, "Value", oldImage, element.Value);
        _commandHistory.ExecuteCommand(command);
    }
}
```

---

### 2.6 图表 (Chart)

#### 基本属性

| 属性名 | 类型 | 默认值 | 说明 |
|--------|------|--------|------|
| `Type` | `ControlType` | `Chart` | 控件类型标识 |
| `DisplayName` | `string` | "图表" | 显示名称 |
| `X` | `double` | 50 | 左上角X坐标（毫米） |
| `Y` | `double` | 50 | 左上角Y坐标（毫米） |
| `Width` | `double` | 200 | 宽度（毫米） |
| `Height` | `double` | 150 | 高度（毫米） |
| `Value` | `object` | null | 图表数据 |
| `EditState` | `EditableState` | `Editable` | 可编辑状态 |

#### 扩展属性

```csharp
// 图表类型
element.SetProperty("ChartType", "Column"); // Column/Line/Pie/Area/Scatter

// 标题
element.SetProperty("ChartTitle", "销售统计");

// X轴标签
element.SetProperty("XAxisTitle", "月份");

// Y轴标签
element.SetProperty("YAxisTitle", "金额");

// 显示图例
element.SetProperty("ShowLegend", true);

// 图例位置
element.SetProperty("LegendPosition", "Top"); // Top/Bottom/Left/Right

// 动画效果
element.SetProperty("EnableAnimation", true);

// 主题颜色
element.SetProperty("Theme", "Default"); // Default/Dark/Colorful

// 数据源
element.SetProperty("DataSource", "TemplateData"); // TemplateData/External
```

---

## 三、表格元素详解

### 3.1 基本属性

| 属性名 | 类型 | 默认值 | 说明 |
|--------|------|--------|------|
| `Type` | `ControlType` | `Table` | 控件类型标识 |
| `DisplayName` | `string` | "表格" | 显示名称 |
| `X` | `double` | 50 | 左上角X坐标（毫米） |
| `Y` | `double` | 50 | 左上角Y坐标（毫米） |
| `Width` | `double` | 200 | 宽度（毫米） |
| `Height` | `double` | 100 | 高度（毫米） |
| `Value` | `object` | null | 表格数据 |
| `EditState` | `EditableState` | `Editable` | 可编辑状态 |

### 3.2 扩展属性

```csharp
// 表格配置（核心）
element.SetProperty("TableConfig", new TableConfig
{
    Columns = new List<ColumnConfig>
    {
        new ColumnConfig
        {
            ColumnId = "col1",
            HeaderText = "姓名",
            ControlType = CellControlType.TextBox,
            Width = 80
        },
        new ColumnConfig
        {
            ColumnId = "col2",
            HeaderText = "部门",
            ControlType = CellControlType.ComboBox,
            Width = 100,
            DropdownOptions = new List<string> { "技术部", "市场部", "销售部" }
        }
    },
    DefaultRowCount = 3,
    AllowAddRow = true,
    AllowDeleteRow = true
});

// 边框样式
element.SetProperty("BorderThickness", new Thickness(1));
element.SetProperty("BorderBrush", "Gray");

// 斑马纹
element.SetProperty("AlternatingRowColors", true);
element.SetProperty("AlternateColor", "#F5F5F5");

// 表头样式
element.SetProperty("HeaderBackground", "#E0E0E0");
element.SetProperty("HeaderForeground", "Black");
element.SetProperty("HeaderFontWeight", "Bold");

// 单元格样式
element.SetProperty("CellPadding", new Thickness(5));
element.SetProperty("VerticalAlignment", "Center"); // Top/Center/Bottom

// 行操作
element.SetProperty("ShowRowNumber", false);
element.SetProperty("RowNumberWidth", 30);
```

### 3.3 表格操作

| 操作 | 方法 | 说明 |
|------|------|------|
| 添加 | `AddElement(ControlType.Table)` | 添加到画布 |
| 编辑表格配置 | `EditTableConfig(element)` | 配置列和行 |
| 编辑单元格 | 双击单元格 | 编辑单元格内容 |
| 添加行 | 工具栏按钮 | 添加新行 |
| 删除行 | 右键菜单 | 删除选中行 |
| 导出Excel | （扩展） | 导出为Excel文件 |

### 3.4 表格配置编辑器

```csharp
[RelayCommand]
private void EditTableConfig(ControlElement element)
{
    if (element.Type == ControlType.Table)
    {
        var config = element.GetProperty<TableConfig>("TableConfig", new TableConfig());
        
        var window = new TableConfigWindow
        {
            DataContext = config,
            Owner = Application.Current.MainWindow,
            WindowStartupLocation = WindowStartupLocation.CenterOwner
        };

        if (window.ShowDialog() == true)
        {
            var oldConfig = element.GetProperty<TableConfig>("TableConfig");
            var newConfig = window.GetConfig();
            
            element.SetProperty("TableConfig", newConfig);
            
            // 记录命令
            var command = new ChangeControlPropertyCommand(
                element, "TableConfig", oldConfig, newConfig);
            _commandHistory.ExecuteCommand(command);
        }
    }
}
```

### 3.5 列头编辑与数据格式

```xaml
<DataGrid AutoGenerateColumns="False">
    <DataGrid.Columns>
        <DataGridTemplateColumn Width="{Binding Width}">
            <DataGridTemplateColumn.HeaderTemplate>
                <DataTemplate>
                    <TextBox Text="{Binding HeaderText, Mode=TwoWay}"
                             BorderThickness="0" Background="Transparent"
                             TextAlignment="Center"/>
                </DataTemplate>
            </DataGridTemplateColumn.HeaderTemplate>
            <DataGridTemplateColumn.CellTemplate>
                <DataTemplate>
                    <ContentControl Content="{Binding}">
                        <ContentControl.ContentTemplateSelector>
                            <local:CellTemplateSelector>
                                <local:CellTemplateSelector.TextBoxTemplate>
                                    <DataTemplate>
                                        <TextBox Text="{Binding Value, Mode=TwoWay}"
                                                 StringFormat="{Binding FormatString}"/>
                                    </DataTemplate>
                                </local:CellTemplateSelector.TextBoxTemplate>
                                <local:CellTemplateSelector.ComboBoxTemplate>
                                    <DataTemplate>
                                        <ComboBox ItemsSource="{Binding DropdownOptions}"
                                                  SelectedItem="{Binding Value}"/>
                                    </DataTemplate>
                                </local:CellTemplateSelector.ComboBoxTemplate>
                            </local:CellTemplateSelector>
                        </ContentControl.ContentTemplateSelector>
                    </ContentControl>
                </DataTemplate>
            </DataGridTemplateColumn.CellTemplate>
        </DataGridTemplateColumn>
    </DataGrid.Columns>
</DataGrid>
```

### 3.6 下拉框单元格默认选中

```csharp
public class TableCell
{
    [ObservableProperty]
    private string _value;

    [ObservableProperty]
    private List<string> _dropdownOptions;

    public TableCell(List<string> options, string defaultValue = null)
    {
        DropdownOptions = options;
        
        // 默认选中第一项或指定值
        Value = defaultValue ?? DropdownOptions.FirstOrDefault();
    }
}

// 使用示例
var cell = new TableCell(
    new List<string> { "男", "女", "其他" },
    "男" // 默认选中"男"
);
```

---

## 四、元素操作指南

### 4.1 通用操作

#### 添加元素

```csharp
// 通过工具栏按钮
[RelayCommand]
private void AddElement(ControlType type)
{
    var newElement = new ControlElement
    {
        Type = type,
        X = 50,
        Y = 50,
        Width = GetDefaultWidth(type),
        Height = GetDefaultHeight(type),
        EditState = EditableState.Editable,
        ZIndex = CurrentTemplate.Layout.EditableElements.Count
    };

    var command = new AddControlCommand(
        CurrentTemplate.Layout.EditableElements, newElement);
    _commandHistory.ExecuteCommand(command);
    
    SelectedElement = newElement;
}

private double GetDefaultWidth(ControlType type)
{
    return type switch
    {
        ControlType.Table => 200,
        ControlType.Image => 150,
        ControlType.Chart => 200,
        _ => 100
    };
}
```

#### 拖拽移动

```csharp
// 附加行为实现
public static class DragDropBehavior
{
    public static readonly DependencyProperty IsDragEnabledProperty =
        DependencyProperty.RegisterAttached(
            "IsDragEnabled",
            typeof(bool),
            typeof(DragDropBehavior),
            new PropertyMetadata(false, OnIsDragEnabledChanged));

    private static void OnIsDragEnabledChanged(
        DependencyObject d,
        DependencyPropertyChangedEventArgs e)
    {
        if (d is UIElement element && (bool)e.NewValue)
        {
            element.MouseLeftButtonDown += Element_MouseLeftButtonDown;
            element.MouseMove += Element_MouseMove;
            element.MouseLeftButtonUp += Element_MouseLeftButtonUp;
        }
    }

    private static Point _startPosition;
    private static bool _isDragging;

    private static void Element_MouseMove(object sender, MouseEventArgs e)
    {
        if (!_isDragging) return;

        var element = sender as FrameworkElement;
        var position = e.GetPosition(null);
        var deltaX = position.X - _startPosition.X;
        var deltaY = position.Y - _startPosition.Y;

        if (element.Parent is Canvas canvas)
        {
            var currentX = Canvas.GetLeft(element);
            var currentY = Canvas.GetTop(element);

            Canvas.SetLeft(element, currentX + deltaX);
            Canvas.SetTop(element, currentY + deltaY);

            _startPosition = position;

            // 更新ViewModel
            if (element.DataContext is ControlElement controlElement)
            {
                controlElement.X = currentX + deltaX;
                controlElement.Y = currentY + deltaY;
            }
        }
    }
}
```

#### 调整大小

```csharp
// 四角Thumb实现
public static class ResizeBehavior
{
    public static readonly DependencyProperty EnableResizeProperty =
        DependencyProperty.RegisterAttached(
            "EnableResize",
            typeof(bool),
            typeof(ResizeBehavior),
            new PropertyMetadata(false, OnEnableResizeChanged));

    private static void OnEnableResizeChanged(
        DependencyObject d,
        DependencyPropertyChangedEventArgs e)
    {
        if (d is FrameworkElement element && (bool)e.NewValue)
        {
            var thumb = new Thumb
            {
                Width = 10,
                Height = 10,
                Cursor = Cursors.SizeNWSE,
                HorizontalAlignment = HorizontalAlignment.Right,
                VerticalAlignment = VerticalAlignment.Bottom
            };

            thumb.DragDelta += (s, args) =>
            {
                var width = element.ActualWidth + args.HorizontalChange;
                var height = element.ActualHeight + args.VerticalChange;

                element.Width = Math.Max(width, 20);
                element.Height = Math.Max(height, 20);

                if (element.DataContext is ControlElement controlElement)
                {
                    controlElement.Width = element.Width;
                    controlElement.Height = element.Height;
                }
            };

            (element as Panel)?.Children.Add(thumb);
        }
    }
}
```

#### 克隆元素

```csharp
[RelayCommand]
private void CloneElement(ControlElement element = null)
{
    var targetElement = element ?? SelectedElement;
    if (targetElement != null)
    {
        var clonedElement = targetElement.Clone();
        clonedElement.ElementId = Guid.NewGuid().ToString();
        
        // 偏移位置
        clonedElement.X += 20;
        clonedElement.Y += 20;
        
        // 设置新层级
        clonedElement.ZIndex = CurrentTemplate.Layout.EditableElements
            .Max(e => e.ZIndex) + 1;
        
        CurrentTemplate.Layout.EditableElements.Add(clonedElement);
        SelectedElement = clonedElement;
    }
}
```

#### 层级管理

```csharp
[RelayCommand]
private void BringToFront()
{
    if (SelectedElement == null) return;

    var maxZIndex = CurrentTemplate.Layout.EditableElements
        .Max(e => e.ZIndex);
    SelectedElement.ZIndex = maxZIndex + 1;
}

[RelayCommand]
private void SendToBack()
{
    if (SelectedElement == null) return;

    var minZIndex = CurrentTemplate.Layout.EditableElements
        .Min(e => e.ZIndex);
    SelectedElement.ZIndex = minZIndex - 1;
}

[RelayCommand]
private void LayerUp()
{
    if (SelectedElement == null) return;

    var currentElement = SelectedElement;
    var nextZIndex = CurrentTemplate.Layout.EditableElements
        .Where(e => e.ZIndex > currentElement.ZIndex)
        .OrderBy(e => e.ZIndex)
        .FirstOrDefault()?.ZIndex;

    if (nextZIndex.HasValue)
    {
        currentElement.ZIndex = nextZIndex.Value + 1;
    }
}

[RelayCommand]
private void LayerDown()
{
    if (SelectedElement == null) return;

    var currentElement = SelectedElement;
    var prevZIndex = CurrentTemplate.Layout.EditableElements
        .Where(e => e.ZIndex < currentElement.ZIndex)
        .OrderByDescending(e => e.ZIndex)
        .FirstOrDefault()?.ZIndex;

    if (prevZIndex.HasValue)
    {
        currentElement.ZIndex = prevZIndex.Value - 1;
    }
}
```

### 4.2 撤销/重做

```csharp
// 命令模式实现
public interface ICommand
{
    void Execute();
    void Undo();
}

public class AddControlCommand : ICommand
{
    private readonly ObservableCollection<ControlElement> _collection;
    private readonly ControlElement _element;

    public AddControlCommand(ObservableCollection<ControlElement> collection, ControlElement element)
    {
        _collection = collection;
        _element = element;
    }

    public void Execute()
    {
        _collection.Add(_element);
    }

    public void Undo()
    {
        _collection.Remove(_element);
    }
}

public class CommandHistory
{
    private readonly Stack<ICommand> _undoStack = new();
    private readonly Stack<ICommand> _redoStack = new();

    public bool CanUndo => _undoStack.Count > 0;
    public bool CanRedo => _redoStack.Count > 0;

    public void ExecuteCommand(ICommand command)
    {
        command.Execute();
        _undoStack.Push(command);
        _redoStack.Clear();
    }

    public void Undo()
    {
        if (_undoStack.Count > 0)
        {
            var command = _undoStack.Pop();
            command.Undo();
            _redoStack.Push(command);
        }
    }

    public void Redo()
    {
        if (_redoStack.Count > 0)
        {
            var command = _redoStack.Pop();
            command.Execute();
            _undoStack.Push(command);
        }
    }
}
```

---

## 五、元素属性配置

### 5.1 属性编辑器界面

```xaml
<Grid>
    <Grid.RowDefinitions>
        <RowDefinition Height="Auto"/>
        <RowDefinition Height="Auto"/>
        <RowDefinition Height="Auto"/>
        <RowDefinition Height="Auto"/>
        <RowDefinition Height="Auto"/>
        <RowDefinition Height="Auto"/>
        <RowDefinition Height="*"/>
    </Grid.RowDefinitions>

    <!-- 基本信息 -->
    <TextBlock Grid.Row="0" Text="基本信息" FontWeight="Bold" Margin="5"/>

    <Grid Grid.Row="1" Margin="10,5">
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="Auto"/>
            <ColumnDefinition Width="*"/>
        </Grid.ColumnDefinitions>

        <TextBlock Grid.Column="0" Text="名称:" VerticalAlignment="Center"/>
        <TextBox Grid.Column="1" Text="{Binding SelectedElement.DisplayName, Mode=TwoWay}" 
                 Margin="5,0,0,0"/>
    </Grid>

    <!-- 位置与大小 -->
    <TextBlock Grid.Row="2" Text="位置与大小" FontWeight="Bold" Margin="5"/>

    <Grid Grid.Row="3" Margin="10,5">
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="Auto"/>
            <ColumnDefinition Width="*"/>
            <ColumnDefinition Width="Auto"/>
            <ColumnDefinition Width="*"/>
        </Grid.ColumnDefinitions>

        <TextBlock Grid.Column="0" Text="X:" VerticalAlignment="Center"/>
        <TextBox Grid.Column="1" Text="{Binding SelectedElement.X, Mode=TwoWorld}" 
                 Margin="5,0"/>
        
        <TextBlock Grid.Column="2" Text="Y:" VerticalAlignment="Center" Margin="10,0,0,0"/>
        <TextBox Grid.Column="3" Text="{Binding SelectedElement.Y, Mode=TwoWorld}" 
                 Margin="5,0,0,0"/>
    </Grid>

    <Grid Grid.Row="4" Margin="10,5">
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="Auto"/>
            <ColumnDefinition Width="*"/>
            <ColumnDefinition Width="Auto"/>
            <ColumnDefinition Width="*"/>
        </Grid.ColumnDefinitions>

        <TextBlock Grid.Column="0" Text="宽度:" VerticalAlignment="Center"/>
        <TextBox Grid.Column="1" Text="{Binding SelectedElement.Width, Mode=TwoWorld}" 
                 Margin="5,0"/>
        
        <TextBlock Grid.Column="2" Text="高度:" VerticalAlignment="Center" Margin="10,0,0,0"/>
        <TextBox Grid.Column="3" Text="{Binding SelectedElement.Height, Mode=TwoWorld}" 
                 Margin="5,0,0,0"/>
    </Grid>

    <!-- 可编辑状态 -->
    <TextBlock Grid.Row="5" Text="状态" FontWeight="Bold" Margin="5"/>

    <Grid Grid.Row="6" Margin="10,5">
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="Auto"/>
            <ColumnDefinition Width="*"/>
        </Grid.ColumnDefinitions>

        <TextBlock Grid.Column="0" Text="可编辑:" VerticalAlignment="Center"/>
        <ComboBox Grid.Column="1" SelectedItem="{Binding SelectedElement.EditState, Mode=TwoWorld}" 
                  Margin="5,0,0,0">
            <ComboBox.Items>
                <local:EditableState>Editable</local:EditableState>
                <local:EditableState>ReadOnly</local:EditableState>
                <local:EditableState>Locked</local:EditableState>
            </ComboBox.Items>
        </ComboBox>
    </Grid>
</Grid>
```

### 5.2 类型特定属性面板

```csharp
// 根据控件类型显示不同属性面板
public partial class PropertyPanelViewModel : ObservableObject
{
    [ObservableProperty]
    private ControlElement _selectedElement;

    [ObservableProperty]
    private ViewModelBase _specificPropertyPanel;

    partial void OnSelectedElementChanged(ControlElement value)
    {
        if (value == null)
        {
            SpecificPropertyPanel = null;
            return;
        }

        SpecificPropertyPanel = value.Type switch
        {
            ControlType.TextBox => new TextBoxPropertyViewModel(value),
            ControlType.ComboBox => new ComboBoxPropertyViewModel(value),
            ControlType.Table => new TablePropertyViewModel(value),
            _ => new DefaultPropertyViewModel(value)
        };
    }
}
```

---

## 六、数据绑定规则

### 6.1 绑定策略

当前项目采用**元素ID绑定策略**：

```csharp
// DataEntryViewModel中
partial void OnUserNameChanged(string value)
{
    // 通过硬编码的key更新
    _sharedDataService.UpdateUserData("UserName", value);
}

// TemplateEditorViewModel中接收
private void UpdateElementValue(string key, object value)
{
    var element = CurrentTemplate.Layout.EditableElements
        .FirstOrDefault(e => e.ElementId == key);
    if (element != null)
    {
        element.Value = value;
    }
}
```

### 6.2 问题分析

**当前实现的缺陷：**

1. **硬编码Key**：`UserName`、`Email`等是硬编码字符串，容易出错
2. **无自动关联**：控件ElementId与数据Key需要手动对应
3. **类型不安全**：没有编译时类型检查

### 6.3 推荐的改进方案（详见改进文档）

---

## 七、高级特性

### 7.1 元数据验证

```csharp
public interface IValidatableElement
{
    List<ValidationResult> Validate();
}

public class ValidationResult
{
    public bool IsValid { get; set; }
    public string ErrorMessage { get; set; }
    public string PropertyName { get; set; }
}

public partial class ControlElement : ObservableObject, IValidatableElement
{
    public List<ValidationResult> Validate()
    {
        var errors = new List<ValidationResult>();

        // 验证必填
        if (GetProperty<bool>("IsRequired", false) && 
            (Value == null || string.IsNullOrEmpty(Value.ToString())))
        {
            errors.Add(new ValidationResult
            {
                IsValid = false,
                ErrorMessage = $"{DisplayName}不能为空",
                PropertyName = "Value"
            });
        }

        // 验证正则
        var regex = GetProperty<string>("ValidationRegex");
        if (!string.IsNullOrEmpty(regex))
        {
            var pattern = new Regex(regex);
            if (!pattern.IsMatch(Value?.ToString() ?? ""))
            {
                errors.Add(new ValidationResult
                {
                    IsValid = false,
                    ErrorMessage = $"{DisplayName}格式不正确",
                    PropertyName = "Value"
                });
            }
        }

        return errors;
    }
}
```

### 7.2 元素联动

```csharp
// 元素事件系统
public class ElementEvent
{
    public string EventName { get; set; }
    public string TargetElementId { get; set; }
    public string Action { get; set; }
    public Dictionary<string, object> Parameters { get; set; }
}

// 在ControlElement中添加
public class ControlElement
{
    public List<ElementEvent> Events { get; set; }

    public void TriggerEvent(string eventName, object value)
    {
        var event = Events?.FirstOrDefault(e => e.EventName == eventName);
        if (event != null)
        {
            // 执行联动逻辑
            ExecuteEvent(event, value);
        }
    }

    private void ExecuteEvent(ElementEvent event, object value)
    {
        switch (event.Action)
        {
            case "SetValue":
                // 设置目标元素的值
                break;
            case "Show":
                // 显示目标元素
                break;
            case "Hide":
                // 隐藏目标元素
                break;
            case "Enable":
                // 启用目标元素
                break;
            case "Disable":
                // 禁用目标元素
                break;
        }
    }
}
```

### 7.3 条件显示

```csharp
// 元素可见性规则
public class VisibilityRule
{
    public string ConditionElementId { get; set; }
    public string Operator { get; set; } // equals/not_equals/contains/regex
    public string ExpectedValue { get; set; }
}

// 应用规则
public bool IsVisible(ControlElement element, Dictionary<string, object> data)
{
    var rule = element.GetProperty<VisibilityRule>("VisibilityRule");
    if (rule == null) return true;

    var conditionValue = data.GetValueOrDefault(rule.ConditionElementId);

    return rule.Operator switch
    {
        "equals" => conditionValue?.ToString() == rule.ExpectedValue,
        "not_equals" => conditionValue?.ToString() != rule.ExpectedValue,
        "contains" => conditionValue?.ToString().Contains(rule.ExpectedValue) ?? false,
        "regex" => Regex.IsMatch(conditionValue?.ToString() ?? "", rule.ExpectedValue),
        _ => true
    };
}
```

---

## 八、总结

当前报告单模板系统已支持以下元素及其操作：

| 元素类型 | 基本操作 | 扩展操作 | 完成度 |
|---------|---------|---------|--------|
| TextBox | 拖拽、调整、克隆、删除 | 验证、格式化、占位符 | ✅ 90% |
| ComboBox | 拖拽、调整、克隆、删除 | 选项编辑、数据源绑定、多选 | ✅ 85% |
| DatePicker | 拖拽、调整、克隆、删除 | 日期范围、禁用日期、快捷日期 | ✅ 80% |
| CheckBox | 拖拽、调整、克隆、删除 | 三态、标签位置、自定义样式 | ✅ 75% |
| Table | 拖拽、调整、克隆、删除 | 列配置、行操作、Excel导出 | ⚠️ 60% |
| Image | 拖拽、调整、克隆、删除 | 裁剪、旋转、滤镜 | ⚠️ 50% |
| Chart | 拖拽、调整、克隆、删除 | 多图表类型、动态数据、动画 | ⚠️ 40% |

**关键优势：**
- ✅ 完整的撤销/重做机制
- ✅ 模板版本控制
- ✅ 数据双向同步
- ✅ 扩展属性系统

**待完善功能：**
- ⚠️ 智能数据绑定（ElementId与数据Key自动关联）
- ⚠️ 元素联动系统
- ⚠️ 条件显示规则
- ⚠️ 高级验证规则
- ⚠️ 表格高级功能（合并单元格、冻结行列）
